
cmake_minimum_required(VERSION 2.8)
#cmake_policy(SET CMP0011 NEW)
#cmake_policy(SET CMP0015 NEW)

###### TARGET PROPERTIES
# LIST_DEPENDENT_PROJECTS - все зависимые проекты, необходимые для текущего. Включая зависимости зависимостей.
# LIST_DEST_PATH - пути, куда следует скопировать цель данного проекта
######
###### GLOBAL PROPERTIES
# LIST_DEPENDS_MODULE - все проекты, которые требуется собрать
# LIST_SHARED_LIBRARY - все динамические библиотеки (включая плагины)
# LIST_EXECUTABLE_PATH -
# LIST_CONFIGS_PATH -
# LIST_REGDLL -
# LIST_UNREGDLL-
######

# Log
#file (WRITE "${PROJECT_BINARY_DIR}/log.txt" "General log file\n")

include("${ROOT_PATH}/project/include/add_start_script.cmake")
include("${ROOT_PATH}/project/include/copy_assets.cmake")
include("${ROOT_PATH}/project/include/collection_doc.cmake")
include("${ROOT_PATH}/project/include/collection_test.cmake")
include("${ROOT_PATH}/project/include/create_install.cmake")
include("${ROOT_PATH}/project/include/binary.cmake")
	
if(NOT DEFINED ROOT_PATH)
	message(FATAL_ERROR "Variable ROOT_PATH not set.")
endif(NOT DEFINED ROOT_PATH)

if(NOT DEFINED PROJECT_NAME)
	message(FATAL_ERROR "Variable PROJECT_NAME not set.")
endif(NOT DEFINED PROJECT_NAME)
get_filename_component(ROOT_PATH ${ROOT_PATH} ABSOLUTE)
set(CMAKE_MODULE_PATH ${ROOT_PATH}/project/templates)

set(GLOBAL_INCLUDE_DIR ${CMAKE_BINARY_DIR}/include) #каталог для хранение автоматически генерируемых заголовочных файлов
if (NOT DEFINED CMAKE_SYSTEM_NAME AND DEFINED PLATFORM) #если еще есть возможность выбрать платформу
	set(CMAKE_TOOLCHAIN_FILE ${ROOT_PATH}/project/platforms/${PLATFORM}.cmake)
endif (NOT DEFINED CMAKE_SYSTEM_NAME AND DEFINED PLATFORM)

#Установка режима сборки по умолчанию на Debug (для генератора Makefiles)
set(CMAKE_BUILD_TYPE_INIT Debug)

set(CMAKE_BUILD_WITH_INSTALL_RPATH TRUE)

if(NOT DEFINED CMAKE_PROJECT_NAME OR CMAKE_PROJECT_NAME STREQUAL PROJECT_NAME)
set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY lib)
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY bin)
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY bin)
else(NOT DEFINED CMAKE_PROJECT_NAME OR CMAKE_PROJECT_NAME STREQUAL PROJECT_NAME)
set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ../../lib)
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ../../bin)
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ../../bin)
endif(NOT DEFINED CMAKE_PROJECT_NAME OR CMAKE_PROJECT_NAME STREQUAL PROJECT_NAME)

#set(${PROJECT_NAME}_CLIENT ${CLIENT})
#unset(CLIENT)

#Если пользователь в командной строке указал имя CLIENT'а или в главном (головном) проекте статиком прописал имя CLIENT'а
if(DEFINED CLIENT)
	set(CLIENT_CONFIG_FILE CLIENT_CONFIG_FILE-NOTFOUND)
	find_file(CLIENT_CONFIG_FILE ${CLIENT}.cmake PATHS ${ROOT_PATH}/project/clients/ NO_DEFAULT_PATH)
	if(${CLIENT_CONFIG_FILE} STREQUAL CLIENT_CONFIG_FILE-NOTFOUND)
		message("Error! ${ROOT_PATH}/project/clients/${CLIENT}.cmake not found!")
		return()
	else(${CLIENT_CONFIG_FILE} STREQUAL CLIENT_CONFIG_FILE-NOTFOUND)
		include(${ROOT_PATH}/project/clients/${CLIENT}.cmake)
	endif(${CLIENT_CONFIG_FILE} STREQUAL CLIENT_CONFIG_FILE-NOTFOUND)
else(DEFINED CLIENT)
	#В противном случае ищем конфигурационный файл по имени главного (головного) проекта
	if(NOT DEFINED CMAKE_PROJECT_NAME OR CMAKE_PROJECT_NAME STREQUAL PROJECT_NAME)
		set(CLIENT_CONFIG_FILE CLIENT_CONFIG_FILE-NOTFOUND)
		find_file(CLIENT_CONFIG_FILE ${PROJECT_NAME}.cmake PATHS ${ROOT_PATH}/project/clients/ NO_DEFAULT_PATH)
		if(${CLIENT_CONFIG_FILE} STREQUAL CLIENT_CONFIG_FILE-NOTFOUND)
			include(${ROOT_PATH}/project/clients/default.cmake)
		else(${CLIENT_CONFIG_FILE} STREQUAL CLIENT_CONFIG_FILE-NOTFOUND)
			include(${ROOT_PATH}/project/clients/${PROJECT_NAME}.cmake)
		endif(${CLIENT_CONFIG_FILE} STREQUAL CLIENT_CONFIG_FILE-NOTFOUND)
	endif(NOT DEFINED CMAKE_PROJECT_NAME OR CMAKE_PROJECT_NAME STREQUAL PROJECT_NAME)
endif(DEFINED CLIENT)

if(NOT DEFINED EXECUTABLE_DIR)
	set(EXECUTABLE_DIR ${CMAKE_BINARY_DIR}/${CMAKE_RUNTIME_OUTPUT_DIRECTORY})
endif(NOT DEFINED EXECUTABLE_DIR)
#if(DEFINED ${PROJECT_NAME}_CLIENT)
#    include(${ROOT_PATH}/project/clients/${${PROJECT_NAME}_CLIENT}.cmake)
#endif (DEFINED ${PROJECT_NAME}_CLIENT)

if(DEFINED PECULIAR_FOLDER)
	set(${PROJECT_NAME}_PECULIAR_FOLDER ${PECULIAR_FOLDER})
	unset(PECULIAR_FOLDER)
endif(DEFINED PECULIAR_FOLDER)

# Если для данной библиотеки предписано специальное месторасположение
# if(DEFINED PECULIAR_FOLDER)
	# set(${PROJECT_NAME}_PECULIAR_FOLDER ${PECULIAR_FOLDER})
	# unset(PECULIAR_FOLDER)
	# #Месторасположение для плагинов
	# set(CMAKE_SHARED_MODULE_PREFIX "${${PROJECT_NAME}_PECULIAR_FOLDER}/")
	# #Месторасположение для динамических библиотек
	# set(CMAKE_SHARED_LIBRARY_PREFIX "${${PROJECT_NAME}_PECULIAR_FOLDER}/")
# else(DEFINED PECULIAR_FOLDER)
	# if(NOT DEFINED COM_DLL)
		# #Месторасположение для плагинов
		# set(CMAKE_SHARED_MODULE_PREFIX "${MODULE_LIBRARY_DIR}/")
	# else(NOT DEFINED COM_DLL)
		# #Месторасположение для com-dll
		# set(CMAKE_SHARED_MODULE_PREFIX "${SHARED_LIBRARY_DIR}/")
	# endif(NOT DEFINED COM_DLL)
	# #Названия бандлов начинаются с org_. По нему и ориентируемся.
	# if(${PROJECT_NAME} MATCHES "org_")
		# #Месторасположение для бандлов
		# #string(REPLACE "_" "." FOLDER_MODULE_NAME ${PROJECT_NAME})
		# #set(CMAKE_SHARED_LIBRARY_PREFIX "${MODULE_LIBRARY_DIR}/${FOLDER_MODULE_NAME}/")
		# set(CMAKE_SHARED_LIBRARY_PREFIX "${MODULE_LIBRARY_DIR}/")
	# else(${PROJECT_NAME} MATCHES "org_")
		# #Месторасположение для динамических библиотек
		# set(CMAKE_SHARED_LIBRARY_PREFIX "${SHARED_LIBRARY_DIR}/")
	# endif(${PROJECT_NAME} MATCHES "org_")
# endif(DEFINED PECULIAR_FOLDER)

if(DEFINED USE_PACKAGE_EX)
	foreach(PACKAGE_EX_NAME ${USE_PACKAGE_EX})
		include(${ROOT_PATH}/project/package/${PACKAGE_EX_NAME}.cmake)
	endforeach(PACKAGE_EX_NAME ${USE_PACKAGE_EX})
endif (DEFINED USE_PACKAGE_EX)
	
function(make_dep_tree)
	if (${CMAKE_SYSTEM_NAME} STREQUAL Linux)
		set_target_properties(${PROJECT_NAME} PROPERTIES INSTALL_RPATH "$ORIGIN")
	elseif (${CMAKE_SYSTEM_NAME} STREQUAL QNX)
		set_target_properties(${PROJECT_NAME} PROPERTIES INSTALL_RPATH ".")
	endif (${CMAKE_SYSTEM_NAME} STREQUAL Linux)

	set(${PROJECT_NAME}_ASSETS ${ASSETS})
	unset(ASSETS)
	
	if(MSVC)
		source_group("src" FILES ${SOURCES})
		source_group("include" FILES ${HEADERS})
		source_group("include" FILES ${MOC_HEADERS})
		source_group("resource" FILES ${RESOURCES})
		source_group("resource" FILES ${UI_SOURCES})
		source_group("generation" FILES ${GENERATION})
		source_group("generation" FILES ${MOC_SOURCES})
		source_group("generation" FILES ${QRC_SOURCES})
		source_group("generation" FILES ${UI_HEADERS})

		if(CMAKE_PROJECT_NAME STREQUAL PROJECT_NAME)
			find_package(VLD)
			if(VLD_FOUND)
				include_directories(${VLD_INCLUDE_DIRS})
			endif(VLD_FOUND)
		endif(CMAKE_PROJECT_NAME STREQUAL PROJECT_NAME)
		if(VLD_FOUND)
			set_property(TARGET ${PROJECT_NAME} APPEND PROPERTY LINK_FLAGS_DEBUG "/include:__imp_?g_vld@@3VVisualLeakDetector@@A \"${VLD_LIBRARIES}\"")
		endif(VLD_FOUND)
	endif(MSVC)
	
	list(LENGTH CMAKE_CONFIGURATION_TYPES COUNT_CONFIG)
	if(${COUNT_CONFIG} GREATER 0)
		set(SUB_FOLDERS ${CMAKE_CONFIGURATION_TYPES})
	else(${COUNT_CONFIG} GREATER 0)
		set(SUB_FOLDERS ".")
	endif(${COUNT_CONFIG} GREATER 0)
	
	#get_target_property(TARGET_TYPE ${PROJECT_NAME} TYPE)
    #if((${TARGET_TYPE} STREQUAL STATIC_LIBRARY) OR (${TARGET_TYPE} STREQUAL SHARED_LIBRARY))
		#set_target_properties(${PROJECT_NAME} PROPERTIES DEBUG_POSTFIX "d")
    #endif((${TARGET_TYPE} STREQUAL STATIC_LIBRARY) OR (${TARGET_TYPE} STREQUAL SHARED_LIBRARY))
	
	# Чтение файла Projects.mk с путями до директорий
	# if(NOT DEFINED LIST_DIR)
		# message("NOT DEFINED LIST_DIR!\n")
		# file(STRINGS ${ROOT_PATH}/project/Projects.mk STR_LIST_DIR)
		# string(REGEX REPLACE "^(.*)=" "" LIST_DIR ${STR_LIST_DIR})
		# Удаление лишних символов (пробелов и комментариев)
		# foreach(PATH_ELEM ${LIST_DIR})
			# string(REGEX REPLACE " " "" LIST_DIR_ ${PATH_ELEM})
			# set(LIST_DIR__ ${LIST_DIR__} ${LIST_DIR_})
		# endforeach(PATH_ELEM ${LIST_DIR})
		# Переменная LIST_DIR хранит пути для поиска зависимых модулей
		# set(LIST_DIR ${LIST_DIR__} project/cmake)
	# endif(NOT DEFINED LIST_DIR)
	#Создание каталогов для заголовочных файлов 
	if (NOT EXISTS ${GLOBAL_INCLUDE_DIR}/)
		file(MAKE_DIRECTORY ${GLOBAL_INCLUDE_DIR})
	endif (NOT EXISTS ${GLOBAL_INCLUDE_DIR}/)
	set(CUR_PROJECT_INCL_DIR ${GLOBAL_INCLUDE_DIR}/${PROJECT_NAME})
	if (NOT EXISTS ${CUR_PROJECT_INCL_DIR}/)
		file(MAKE_DIRECTORY ${CUR_PROJECT_INCL_DIR})
	else (NOT EXISTS ${CUR_PROJECT_INCL_DIR}/)
		if (NOT DEFINED ${PROJECT_NAME}_OLD_HEADERS) #если каталог существует, а кеш пустой, то возможно он содержит неправильные заголовки
			file(REMOVE_RECURSE ${CUR_PROJECT_INCL_DIR}/)
			file(MAKE_DIRECTORY ${CUR_PROJECT_INCL_DIR})
		endif (NOT DEFINED ${PROJECT_NAME}_OLD_HEADERS)
	endif (NOT EXISTS ${CUR_PROJECT_INCL_DIR}/)

	set(FULL_HEADERS_LIST ${HEADERS} ${MOC_HEADERS})
	
	if (DEFINED ${PROJECT_NAME}_OLD_HEADERS AND ${PROJECT_NAME}_OLD_HEADERS) #если cmake для данного проекта запускается не первый раз
		set(REM_HEADERS ${${PROJECT_NAME}_OLD_HEADERS}) #Массив заголовков которые надо удалить
		if (FULL_HEADERS_LIST)
			list(REMOVE_ITEM REM_HEADERS ${FULL_HEADERS_LIST}) #Удаление из массива элементов, которые есть в измененом проекте
			# message("REM_HEADERS: ${REM_HEADERS}")
		endif (FULL_HEADERS_LIST)
	endif (DEFINED ${PROJECT_NAME}_OLD_HEADERS AND ${PROJECT_NAME}_OLD_HEADERS)
	
	# Удаление лишних (исключенных из проекта) файлов
	foreach (CUR_HEADER ${REM_HEADERS})
		get_filename_component(CUR_HEADER_NAME ${CUR_HEADER} NAME)
		if (EXISTS ${CUR_PROJECT_INCL_DIR}/${CUR_HEADER_NAME})
			file(REMOVE ${CUR_PROJECT_INCL_DIR}/${CUR_HEADER_NAME})
		endif (EXISTS ${CUR_PROJECT_INCL_DIR}/${CUR_HEADER_NAME})
	endforeach (CUR_HEADER ${REM_HEADERS})
	
	# Создание недостающих файлов
	foreach (CUR_HEADER ${FULL_HEADERS_LIST})
		get_filename_component(CUR_HEADER_NAME ${CUR_HEADER} NAME)
		if (NOT EXISTS ${CUR_PROJECT_INCL_DIR}/${CUR_HEADER_NAME})
			file(RELATIVE_PATH CUR_HEADER_RPATH ${CUR_PROJECT_INCL_DIR} ${CMAKE_CURRENT_SOURCE_DIR}/${CUR_HEADER})
			file(WRITE ${CUR_PROJECT_INCL_DIR}/${CUR_HEADER_NAME} "#include \"${CUR_HEADER_RPATH}\"\n")
		endif (NOT EXISTS ${CUR_PROJECT_INCL_DIR}/${CUR_HEADER_NAME})
	endforeach (CUR_HEADER ${FULL_HEADERS_LIST})
	
	# Сохраниение в кеше массива заголовков данного проекта,
	# при последующих запусках cmake это будет массив заголовков
	# которые были у проекта до его изменения
	set(${PROJECT_NAME}_OLD_HEADERS ${FULL_HEADERS_LIST} CACHE INTERNAL "old headers")
	
	# Подключаем зависимые модули, указанные в переменной DEPENDS_MODULE
	message("[${PROJECT_NAME}]: DEPENDS_MODULE -> ${DEPENDS_MODULE}\n")

	#message("CMAKE_CURRENT_SOURCE_DIR: ${CMAKE_CURRENT_SOURCE_DIR}")
	#message("CMAKE_CURRENT_BINARY_DIR: ${CMAKE_CURRENT_BINARY_DIR}")
	#include(${ROOT_PATH}/project/module_list.cmake)
	set(LIST_DEPENDENT_PROJECTS ${DEPENDS_MODULE})
	set(${PROJECT_NAME}_DEPENDS ${DEPENDS_MODULE})
	unset(DEPENDS_MODULE)
	set(${PROJECT_NAME}_SOURCES ${SOURCES})
	set(${PROJECT_NAME}_HEADERS ${HEADERS})
	get_target_property(${PROJECT_NAME}_IMPORTED ${PROJECT_NAME} IMPORTED)
	foreach(MODULE_NAME ${${PROJECT_NAME}_DEPENDS})
		unset(SOURCES)
		unset(HEADERS)
		unset(MOC_HEADERS)
		unset(RESOURCES)
		unset(MOC_SOURCES)
		unset(QRC_SOURCES)
		unset(UI_SOURCES)
		unset(UI_HEADERS)
		get_property(LIST_DEPENDS_MODULE GLOBAL PROPERTY LIST_DEPENDS_MODULE)
		if(DEFINED LIST_DEPENDS_MODULE)
			list(FIND LIST_DEPENDS_MODULE ${MODULE_NAME} USED_MODULE)
			message("============================================")
			message("FIND (${MODULE_NAME}) in LIST_DEPENDS_MODULE : ${USED_MODULE}")
			message("============================================")
		else(DEFINED LIST_DEPENDS_MODULE)
			set(USED_MODULE -1)
		endif(DEFINED LIST_DEPENDS_MODULE)
		
		if(NOT DEFINED ${MODULE_NAME}_LIBRARY)
			find_package(${MODULE_NAME} REQUIRED PATHS ${ROOT_PATH} PATH_SUFFIXES project/modules)
			if(NOT DEFINED ${MODULE_NAME}_LIBRARY)
				message(FATAL_ERROR "Error in ${MODULE_NAME}-config.cmake. Variable ${MODULE_NAME}_LIBRARY not defined!")
				return()
			endif(NOT DEFINED ${MODULE_NAME}_LIBRARY)
		endif(NOT DEFINED ${MODULE_NAME}_LIBRARY)

		if(${USED_MODULE} EQUAL -1)
			set_property(GLOBAL APPEND PROPERTY LIST_DEPENDS_MODULE ${MODULE_NAME})
			message("=========== ${CMAKE_SYSTEM_NAME} - ${CMAKE_SYSTEM_VERSION} ${CMAKE_SYSTEM_PROCESSOR}")
			#add_subdirectory(${ROOT_PATH}/${${MODULE_NAME}_LIBRARY} ${ROOT_PATH}/${${MODULE_NAME}_LIBRARY}/${PATH_SUFIX})
			message("CMAKE_BINARY_DIR: ${CMAKE_BINARY_DIR}")
      if ( NOT EXISTS "${ROOT_PATH}/${${MODULE_NAME}_LIBRARY}/CMakeLists.txt" )
        message(FATAL_ERROR "Error in ${MODULE_NAME}-config.cmake. File ${ROOT_PATH}/${${MODULE_NAME}_LIBRARY}/CMakeList.txt not found!")
				return()
      endif ( NOT EXISTS "${ROOT_PATH}/${${MODULE_NAME}_LIBRARY}/CMakeLists.txt" )
      add_subdirectory(${ROOT_PATH}/${${MODULE_NAME}_LIBRARY} ${CMAKE_BINARY_DIR}/subproject/${MODULE_NAME})
	 		#get_property(LIST_DEPENDS_MODULE GLOBAL PROPERTY LIST_DEPENDS_MODULE)
		else(${USED_MODULE} EQUAL -1)
			message("[${PROJECT_NAME}]: ${MODULE_NAME}-${USED_MODULE} ENABLE!")
		endif(${USED_MODULE} EQUAL -1)
		get_target_property(${MODULE_NAME}_TYPE ${MODULE_NAME} TYPE)
		if((${${MODULE_NAME}_TYPE} STREQUAL STATIC_LIBRARY) OR (${${MODULE_NAME}_TYPE} STREQUAL SHARED_LIBRARY))
			if (NOT ${PROJECT_NAME}_IMPORTED)
				target_link_libraries(${PROJECT_NAME} ${MODULE_NAME})
			else (NOT ${PROJECT_NAME}_IMPORTED)
				set_property(TARGET ${PROJECT_NAME} APPEND PROPERTY IMPORTED_LINK_INTERFACE_LIBRARIES ${MODULE_NAME})
			endif (NOT ${PROJECT_NAME}_IMPORTED)
			link_directories(${ROOT_PATH}/${${MODULE_NAME}_LIBRARY}/bin) #??
			#get_directory_property(INCL_DIRS DIRECTORY ${ROOT_PATH}/${${MODULE_NAME}_LIBRARY} INCLUDE_DIRECTORIES)
			#include_directories(${INCL_DIRS})
			if(${${MODULE_NAME}_TYPE} STREQUAL STATIC_LIBRARY)
				string(TOUPPER ${MODULE_NAME} STATIC_MODULE_NAME)
				add_definitions(-D${STATIC_MODULE_NAME}_STATICLIB)
			endif(${${MODULE_NAME}_TYPE} STREQUAL STATIC_LIBRARY)
		endif((${${MODULE_NAME}_TYPE} STREQUAL STATIC_LIBRARY) OR (${${MODULE_NAME}_TYPE} STREQUAL SHARED_LIBRARY))
		#include_directories(${ROOT_PATH}/${${MODULE_NAME}_LIBRARY}/include)
		add_dependencies(${PROJECT_NAME} ${MODULE_NAME})
		get_property(CHILD_DEPENDS TARGET ${MODULE_NAME} PROPERTY LIST_DEPENDENT_PROJECTS)
		if(DEFINED CHILD_DEPENDS)
			list(APPEND LIST_DEPENDENT_PROJECTS ${CHILD_DEPENDS})
		endif(DEFINED CHILD_DEPENDS)
	endforeach(MODULE_NAME ${${PROJECT_NAME}_DEPENDS})
	list(LENGTH LIST_DEPENDENT_PROJECTS LIST_DEPENDENT_PROJECTS_LEN)
	if(LIST_DEPENDENT_PROJECTS_LEN GREATER 0)
		list(REMOVE_DUPLICATES LIST_DEPENDENT_PROJECTS)
	endif(LIST_DEPENDENT_PROJECTS_LEN GREATER 0)
	set_property(TARGET ${PROJECT_NAME} PROPERTY LIST_DEPENDENT_PROJECTS ${LIST_DEPENDENT_PROJECTS})
	
	include_directories(${ROOT_PATH}/include)
	if (IS_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/include)
		include_directories(include)
	endif (IS_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/include)
	if (IS_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/../include)
		include_directories(../include)
	endif (IS_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/../include)
	include_directories(${GLOBAL_INCLUDE_DIR})
	include_directories(${CMAKE_CURRENT_BINARY_DIR})
	include_directories("${CMAKE_BINARY_DIR}/subproject")
	foreach(MODULE_NAME ${${PROJECT_NAME}_DEPENDS})
		include_directories(${CMAKE_BINARY_DIR}/subproject/${MODULE_NAME})
		#include_directories("${CMAKE_CURRENT_BINARY_DIR}/__/include")
		#include_directories("${CMAKE_BINARY_DIR}/${MODULE_NAME}/__/include")
	endforeach(MODULE_NAME ${${PROJECT_NAME}_DEPENDS})
	get_target_property(CURRENT_TARGET_TYPE ${PROJECT_NAME} TYPE)

	if(${CURRENT_TARGET_TYPE} STREQUAL SHARED_LIBRARY)
		# Если для данной библиотеки предписано специальное месторасположение
		if(DEFINED ${PROJECT_NAME}_PECULIAR_FOLDER)
			set_output_dir(${PROJECT_NAME} RUNTIME_OUTPUT_DIRECTORY "${${PROJECT_NAME}_PECULIAR_FOLDER}")
			set_output_dir(${PROJECT_NAME} LIBRARY_OUTPUT_DIRECTORY "${${PROJECT_NAME}_PECULIAR_FOLDER}")
		else(DEFINED ${PROJECT_NAME}_PECULIAR_FOLDER)
			set_output_dir(${PROJECT_NAME} RUNTIME_OUTPUT_DIRECTORY "${SHARED_LIBRARY_DIR}")
			set_output_dir(${PROJECT_NAME} LIBRARY_OUTPUT_DIRECTORY "${SHARED_LIBRARY_DIR}")
		endif(DEFINED ${PROJECT_NAME}_PECULIAR_FOLDER)
		#remove_definitions(-D${PROJECT_NAME}_EXPORTS)
		string(TOUPPER ${PROJECT_NAME} SHARED_MODULE_NAME)
		add_definitions(-D${SHARED_MODULE_NAME}_EXPORTS)
	elseif(${CURRENT_TARGET_TYPE} STREQUAL MODULE_LIBRARY)
		# Если для данной библиотеки предписано специальное месторасположение
		if(DEFINED ${PROJECT_NAME}_PECULIAR_FOLDER)
			set_output_dir(${PROJECT_NAME} LIBRARY_OUTPUT_DIRECTORY "${${PROJECT_NAME}_PECULIAR_FOLDER}")
		else(DEFINED ${PROJECT_NAME}_PECULIAR_FOLDER)
			if(DEFINED COM_DLL)
				set_output_dir(${PROJECT_NAME} LIBRARY_OUTPUT_DIRECTORY "${SHARED_LIBRARY_DIR}")
			else(DEFINED COM_DLL)
				set_output_dir(${PROJECT_NAME} LIBRARY_OUTPUT_DIRECTORY "${MODULE_LIBRARY_DIR}")
			endif(DEFINED COM_DLL)
		endif(DEFINED ${PROJECT_NAME}_PECULIAR_FOLDER)
		#remove_definitions(-D${PROJECT_NAME}_EXPORTS)
		string(TOUPPER ${PROJECT_NAME} SHARED_MODULE_NAME)
		add_definitions(-D${SHARED_MODULE_NAME}_EXPORTS)
	elseif(${CURRENT_TARGET_TYPE} STREQUAL STATIC_LIBRARY)
		string(TOUPPER ${PROJECT_NAME} STATIC_MODULE_NAME)
		add_definitions(-D${STATIC_MODULE_NAME}_STATICLIB)
	endif(${CURRENT_TARGET_TYPE} STREQUAL SHARED_LIBRARY)

	if(MSVC)
		add_definitions(-DUNICODE -D_UNICODE)
	endif(MSVC)
	if(MSVC)
		set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} /W4" PARENT_SCOPE)
		set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} /W4 /EHsc /wd4351 /wd4503 /wd4512 /wd4996 /wd4127 /wd4125" PARENT_SCOPE)
	else(MSVC)
		set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -Wall -Wextra -fPIC" PARENT_SCOPE)
		set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall -Wextra -fPIC" PARENT_SCOPE)
	endif(MSVC)
	get_property(LIST_DEPENDENT_PROJECTS TARGET ${PROJECT_NAME} PROPERTY LIST_DEPENDENT_PROJECTS)
	add_start_script()
	copy_assets()
	collection_doc()
	collection_test()
	create_install()
endfunction()


function(set_output_dir prj_name prj_type add_folder)
	foreach(SUB_FOLDER ${SUB_FOLDERS})
		if(${SUB_FOLDER} STREQUAL ".")
			set_target_properties(${prj_name} PROPERTIES ${prj_type} "${CMAKE_${prj_type}}/${add_folder}")
		else(${SUB_FOLDER} STREQUAL ".")
			string(TOUPPER ${SUB_FOLDER} SUB_FOLDER_UPPER)
			set_target_properties(${prj_name} PROPERTIES ${prj_type}_${SUB_FOLDER_UPPER} "${CMAKE_${prj_type}}/${SUB_FOLDER}/${add_folder}")
		endif(${SUB_FOLDER} STREQUAL ".")
	endforeach(SUB_FOLDER ${SUB_FOLDERS})
endfunction()